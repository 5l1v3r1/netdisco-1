#!/usr/bin/env perl

use Dancer ':syntax :script';
use Dancer::Plugin::DBIC 'schema';

# add dispatch methods for each port control action
use base 'Netdisco::PortControl';

use Daemon::Generic::While1;
use Netdisco::Util 'load_nd_config';
use Try::Tiny;

newdaemon(
  progname => 'netdisco-daemon',
  ($> != 0 ? (pidbase => './') : ()),
  configfile => '/etc/netdisco/netdisco.conf',
  logpriority => 'daemon.info',
);

sub gd_preconfig {
  my $self = shift;
  my $config = load_nd_config($self->{configfile});

  $self->gd_error("No read-write community string has been set.")
    unless length $config->{_}->{community_rw};

  # add local settings
  $config->{loc} = {
    sleep_time => 5,
  };

  return (); # important
}

sub dispatch {
  my ($self, $job) = @_;

  # do update
  my %dispatch = (
    location => 'set_location',
  );

  my $target = $dispatch{$job->action}
    or return ();

  # return results
  return $self->$target($job);
}

sub gd_run_body {
  my $self = shift;
  my $nd_config = var('nd_config');

  # get all pending jobs
  my $rs = schema('netdisco')->resultset('Admin')->search({
    action => [qw/location contact portcontrol portname vlan/],
    status => 'queued',
  });

  JOB: while (my $job = $rs->next) {
      # filter for discover_*
      my $device = NetAddr::IP::Lite->new($job->device) or next JOB;

      if (length $nd_config->{_}->{discover_no}) {
          my @d_no = split /,\s*/, $nd_config->{_}->{discover_no};
          foreach my $item (@d_no) {
              my $ip = NetAddr::IP::Lite->new($item) or next JOB;
              next JOB if $ip->contains($device);
          }
      }

      if (length $nd_config->{_}->{discover_only}) {
          my $okay = 0;
          my @d_only = split /,\s*/, $nd_config->{_}->{discover_only};
          foreach my $item (@d_only) {
              my $ip = NetAddr::IP::Lite->new($item) or next JOB;
              ++$okay if $ip->contains($device);
          }
          next JOB if not $okay;
      }

      # lock db table, check job state is still queued, update to running
      try {
          my $status_updated = schema('netdisco')->txn_do(sub {
              my $row = schema('netdisco')->resultset('Admin')->find(
                {job => $job->job},
                {for => 'update'}
              );

              return 0 if $row->status ne 'queued';
              $row->update({status => 'running', started => \'now()'});
              return 1;
          });

          next JOB if not $status_updated;
      }
      catch {
          warn "error updating job status: $_\n";
          next JOB;
      };

      # do job
      my ($status, $log) = $self->dispatch($job);

      # revert to queued status if we failed to connect to device
      if (not $status) {
          try {
              schema('netdisco')->resultset('Admin')
                ->find($job->job)
                ->update({status => 'queued', started => undef});
          }
          catch {  warn "error updating job: $_\n" };
      }
      else {
          # update job state to done/error with log
          try {
              schema('netdisco')->resultset('Admin')
                ->find($job->job)
                ->update({status => $status, log => $log, finished => \'now()'});
          }
          catch {  warn "error updating job: $_\n" };
      }
  }

  $self->gd_sleep( $nd_config->{loc}->{sleep_time} );
}

