#!/usr/bin/env perl

use Dancer qw/:moose :script/;
use Dancer::Plugin::DBIC 'schema';

use Daemon::Generic::While1;
use Parallel::Prefork;
use Role::Tiny;

my $pp = Parallel::Prefork->new(
  max_workers    => 2,
  spawn_interval => 2,
  trap_signals => {
    TERM => 'TERM',
    INT  => 'TERM',
    HUP  =>  undef, # catch but don't relay to workers
  },
);

newdaemon(
  progname => 'netdisco-daemon',
  ($> != 0 ? (pidbase => './') : ()),
  logpriority => 'daemon.info',
);

before 'gd_quit_event' => sub {
  $pp->wait_all_children;
};

# main manager loop
sub gd_run_body {
  my $self = shift;

  # time to die...
  if ($pp->signal_received =~ m/^(?:TERM|INT)$/) {
      $self->gd_quit_event;
  }

  # reload config and kill workers
  if ($pp->signal_received eq 'HUP') {
      # clear signal
      $pp->signal_received('');

      # reload dancer config
      %Dancer::Config::_LOADED = ();
      Dancer::Config::load();

      # kill workers (they will be restarted)
      $pp->signal_all_children('TERM');
      $pp->wait_all_children();
      $pp->{_no_adjust_until} = 0; # BUG in Prefork.pm
  }

  if ($pp->num_workers < $pp->max_workers) {
      $pp->start and return;
      with 'Netdisco::Daemon::Worker::Interactive';
      $self->worker_body;
      $pp->finish;
  }

  # check for new jobs, take one if available
  $self->manager_body;

  $self->gd_sleep( setting('daemon_sleep_time') || 5 );
}

# do not remove - must be redefined for Daemon::Generic
sub gd_preconfig { return () }

# nullify this so we allow Parallel::Prefork to register handlers instead
sub gd_setup_signals {}

